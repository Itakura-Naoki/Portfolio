<?php
/*
宣言していない変数の呼び出し
→変数の代入と出力の際に変数ログリストを検索し、なければエラー
戻り値に3
*/
function call_non_variable($name , $variable_log){
    foreach($variable_log as $key => $val){
        if($val["name"] == $name){
            return ['num' => 0  , 'detail' => null , 'origin' => null];
        }
    }
    return ['num' => 3  , 'detail' => $name . 'は宣言されていません' , 'origin' => 'シンボルを見つけられません'];
}

/*
宣言した変数と違う型の代入
・代入のみする場合（処理番号が4の場合）
→変数ログリストを検索し、記録されている型と値の型を比較する
全て戻り値に2
*/
function assign_def_type($name , $value , $variable_log){
    $variable_type = ["int" => "int" , "double" => "double" , "String" => "string"];
    foreach($variable_log as $key => $val){
        if($val['name'] == $name){
            if('is_'.$variable_type[$val['type']].($value)){//$value = 代入する値
                return ['num' => 0  , 'detail' => null , 'origin' => null];
            }
        }
    }
    return ['num' => 2 , 'detail' => $value.'と'.$name.'の型が異なります' , 'origin' => '不適合な型'];
}

/*
宣言した変数と違う型の代入
・宣言と代入を同時にする場合（処理番号が3の場合）
→変数ログリストを検索し、記録されている型と値の型を比較する
全て戻り値に2
*/
function dec_assign_deftype($type,$value){
    $variable_type = ["int" => "int" , "double" => "double" , "String" => "string"];
    if($type == 'int' || $type == 'double'){
        if(is_numeric($value)){
            if(($type == "int" && !strpos($value,".")) || $type == "double"){
                return ['num' => 0  , 'detail' => null , 'origin' => null];
            }
            return ['num' => 2 , 'detail' => $value.'と宣言された型が異なります' , 'origin' => '不適合な型'];
        }
        return ['num' => 2 , 'detail' => $value.'と宣言された型が異なります' , 'origin' => '不適合な型'];
    }
    elseif($type == 'String'){
        if($value == '"'){
            return ['num' => 0  , 'detail' => null , 'origin' => null];
        }
        return ['num' => 2 , 'detail' => $value.'と宣言された型が異なります' , 'origin' => '不適合な型'];
    }
}

/*
変数の再宣言
→変数ログリストを検索し、検索にヒットした場合エラーにする
戻り値に4
*/
function redev_variable($name , $variable_log){
    foreach($variable_log as $key => $val){
        if($val["name"] == $name){
            return ['num' => 4 , 'detail' => $name.'は既に定義されています' , 'origin' => '変数'.$name.'はすでに定義されています'];
        }
    }
    return ['num' => 0  , 'detail' => null , 'origin' => null];
}

/*
System.out.printlnとなっているかの検索
戻り値に1
*/
function sqelling_System($out,$print){
    if($out != "out"){
        return ['num' => 1  , 'detail' => '記述ミス('.$out.')' , 'origin' => 'シンボルを見つけられません'];
    }
    elseif($print != "print" && $print != "println"){
        return ['num' => 1  , 'detail' => '記述ミス('.$print.')' , 'origin' => 'シンボルを見つけられません'];
    }
    return ['num' => 0  , 'detail' => null , 'origin' => null];
}

/*
宣言してはいけない変数名で宣言している
→変数名を予約語リストに検索をかける
戻り値に1
*/
function error_naming_variable($name , $variable_Word){
    if(array_search($name,$variable_Word)){
        return ['num' => 1  , 'detail' => '変数'.$name.'は使用できません' , 'origin' => '文ではありません'];
    }
    return ['num' => 0  , 'detail' => null , 'origin' => null];
}

/*
変数名の先頭が数字でないかの判定
→変数名の先頭に数値判定をかける
戻り値に1
*/
function number_name_first($name){
    if(is_numeric(substr($name,0,1))){
        return ['num' => 1  , 'detail' => '変数'.$name.'は使用できません' , 'origin' => '文ではありません'];
    }
    return ['num' => 0  , 'detail' => null , 'origin' => null];
}


// ---------------------------------------------------------------------


//エラーの判定
/*
1.宣言していない変数の呼び出し
→変数の代入と出力の際に変数ログリストを検索し、なければエラー
戻り値に3

2.宣言した変数と違う型の代入
・代入のみする場合（処理番号が4の場合）
→変数ログリストを検索し、記録されている型と値の型を比較する
・宣言と同時に代入する場合（処理番号が3の場合）
→型宣言と代入される値を比較する
全て戻り値に2

3.変数の再宣言
→変数ログリストを検索し、検索にヒットした場合エラーにする
戻り値に4

4.書き間違い（;の記入忘れ）
・処理が出力の場合のみ
→System.out.printlnとなっているかの検索
・全てで実施
→単語リストの最後が";"であるかどうかを判定する
戻り値に1

5.宣言してはいけない変数名で宣言している
→変数名を予約語リストに検索をかける
戻り値に1

6.命名規則から外れた変数名
→変数名を命名規則の網にかける
戻り値に1

1.word_listの最後が";"かどうか
OK → 2に移動
NG → エラー番号を決定し終了（戻り値は1）

2.処理番号を元にエラー判定を分岐させる
・処理番号が1の場合
2‐1‐1.変数に使用してはいけない単語を使用しているかを検索
OK → 2-1‐2に移動
NG → エラー番号を決定し終了（戻り値は1）
2‐1‐2.変数の再宣言がされていないか
OK → 0を返し終了
NG → エラー番号を決定し終了（戻り値は4）

・処理番号が2の場合
2‐2‐1.変数が宣言されているかの判定
OK → 2‐2‐2に移動
NG → エラー番号を決定し終了（戻り値は3）
2‐2‐2.宣言されている値と代入される値の比較
OK → 0を返し終了
NG → エラー番号を決定し終了（戻り値は2）

・処理番号が3の場合
2‐3‐1.変数に使用してはいけない単語を使用しているか
OK → 2‐3‐2に移動
NG → エラー番号を決定して終了（戻り値は1）
2‐3‐2.変数が再宣言されていないか
OK → 2‐3‐3に移動
NG → エラー番号を決定して終了（戻り値は4）
2‐3‐3.宣言されている値の型と代入される値の型の比較
OK → 0を返し終了
NG → エラー番号を決定して終了（戻り値は2）

・処理番号が4の場合
2‐4‐1.変数が宣言されているかの判定
OK → 2‐4‐2へ移動
NG → エラー番号を決定して終了（戻り値は3）

2‐4‐2.宣言されている型と代入される値の型の比較
・キャスト先が変数の場合
2‐4‐2‐1.変数ログに変数があるかの判定
OK → 2‐4‐2‐1に移動
NG → エラー番号を決定して終了（戻り値は3）
2‐4‐2‐2.キャスト可能かの判定
OK → 3に移動
NG → エラー番号を決定して終了（戻り値は2）

・キャスト先が定数の場合
2‐4‐2‐1.キャスト可能かの判定
OK → 3に移動
NG → エラー番号を決定して終了（戻り値は2）

・処理番号が5の場合
2‐5‐1.System.out.printlnと記述されているか
OK → 2‐5‐2へ移動
NG → エラー番号を決定して終了（戻り値は1）
2‐5‐2.変数が宣言されているかの判定
OK → 0を返し終了
NG → エラー番号を決定して終了（戻り値は3）
/

/
変数ログリストに記入
変数ログリストの構成
["変数名","変数の型","変更前の値","変更後の値"]

・処理が「1.変数の宣言」の場合
　　変数名　→　リストの1
　　変数の型　→　リストの0
　　変更前の値　→　なし（要検討）
　　変更後の値　→　なし（要検討）

・処理が「2.変数の代入」の場合
　　変数名　→　リストの0
　　変数の型　→　変数ログを検索し、一番最後にヒットした型を記録
　　変更前の値　→　変数ログを検索し、一番最後にヒットした「変更後の値」を記録
　　変更後の値　→　リストの2

・処理が「3.変数の宣言と代入」の場合
　　変数名　→　リストの1
　　変数の型　→　リストの0
　　変更前の値　→　なし（要検討）
　　変更後の値　→　リストの3

・処理が「4.変数のキャスト」の場合
　　変数名　→　リストの0
　　変数の型　→　リストの3
　　変更前の値　→　変数ログを検索し、一番最後にヒットした「変更後の値」を記録
　　変更後の値　→　リストの5をリストの3でキャストした値を記録
　　　　　　　　　（リストの5が変数名である場合は変数ログに検索をかけて一番最後にヒットした「変更後の値」をキャストする）

・処理が「5.出力」の場合
　　変数ログに変更なし

・処理が「6.コメントアウト」の場合
　　変数ログに変更なし
*/
?>